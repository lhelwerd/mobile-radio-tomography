# Core imports
import unittest

# Library imports
import numpy as np

# Package imports
from ..reconstruction.Gaussian_Model import Gaussian_Model
from ..settings.Arguments import Arguments

class TestReconstructionGaussianModel(unittest.TestCase):
    def setUp(self):
        super(TestReconstructionGaussianModel, self).setUp()

        self.arguments = Arguments("settings.json", [])
        self.settings = self.arguments.get_settings("reconstruction_gaussian_model")

        self.model = Gaussian_Model(self.arguments)

    def test_initialization(self):
        # The sigma member variable must be set.
        self.assertEqual(self.model._sigma, self.settings.get("sigma"))

    def test_type(self):
        # The `type` property must be implemented and correct.
        self.assertEqual(self.model.type, "reconstruction_gaussian_model")

    def test_assign(self):
        def distance(x, y):
            # Helper function to calculate the distance from location
            # (0, 0) to the pixel center location of pixel (x, y).
            return np.sqrt((x + 0.5) ** 2 + (y + 0.5) ** 2)

        # The grid contains 16 pixels (four by four). The link goes from
        # location (0, 0) to location (4, 4). Location (0, 0) is located
        # in the top left corner and location (4, 4) is located in the
        # bottom right corner of the grid.
        length = np.sqrt(4 ** 2 + 4 ** 2)
        source_distances = np.array([
            distance(0, 0), distance(1, 0), distance(2, 0), distance(3, 0),
            distance(0, 1), distance(1, 1), distance(2, 1), distance(3, 1),
            distance(0, 2), distance(1, 2), distance(2, 2), distance(3, 2),
            distance(0, 3), distance(1, 3), distance(2, 3), distance(3, 3)
        ]).reshape(4, 4)
        destination_distances = np.flipud(np.fliplr(source_distances))

        # The assigned weights must be generated by the Gaussian function.
        weights = self.model.assign(length, source_distances, destination_distances)

        summed_distances = source_distances + destination_distances
        expected = self.model._gaussian(summed_distances - length)

        self.assertTrue((weights == expected).all())

    def test_gaussian(self):
        self.model._sigma = 0.3

        # The Gaussian function must use alpha value 1 and mu value 0.
        self.assertEqual(self.model._gaussian(0), 1)

        # The Gaussian function must use the value for sigma. It must also be
        # symmetrical at mu value 0, so a negative value must yield the same
        # result as the corresponding positive value.
        self.assertAlmostEqual(self.model._gaussian(-0.3), 0.6, delta=0.01)
        self.assertAlmostEqual(self.model._gaussian(0.3), 0.6, delta=0.01)

        self.assertAlmostEqual(self.model._gaussian(-1), 0.004, delta=0.001)
        self.assertAlmostEqual(self.model._gaussian(1), 0.004, delta=0.001)
